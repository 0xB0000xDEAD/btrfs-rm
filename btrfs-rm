#!/usr/bin/python
import subprocess
import os
import argparse
DRY_RUN=True
DEBUG_LEVEL=0
class BTRFS: 

  def log_info(self, msg):
    print("INFO: "+msg)
  def log_error(self, msg):
    print("ERROR: "+msg)

  def subprocess(self, args):
    proc = subprocess.Popen(args,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    return proc

  def execute(self, args):
    proc      = self.subprocess(args)
    array     = self.read_stdout(proc.stdout)
    exit_code = proc.wait()
    return (exit_code,array)

  def read_stdout(self, stream):
    array=[] 
    for line in stream:
      # "chomp" 
      item=line.rstrip("\n")
      array.append(item)
    return array

  def show(self, btrfs_dir, verbose=False):
    args = ['btrfs','subvolume', 'show', btrfs_dir]
    if DEBUG_LEVEL > 0:
        self.log_info(" ".join(args))
    return self.execute(args)

  def find_btrfs(self, btrfs_dir):
    while True:
        exit_code,array = self.show(btrfs_dir)
        if btrfs_dir == '/':
            break
        if exit_code != 1:
            break
        # Move one level up
        btrfs_dir = os.path.dirname(btrfs_dir)
    if exit_code != 0:
        return (None,None)
    if len(array) == 1:
        btrfs_name = ""
    else:
        btrfs_name = array[1].split()[1]
    return (btrfs_dir, btrfs_name)

  def subvolume_list_raw(self,btrfs_dir):
    args = ['btrfs','subvolume', 'list', '-o', btrfs_dir ]
    if DEBUG_LEVEL > 0:
      print(" ".join(args))
    return self.execute(args)

  def subvolume_list_extract_dirs(self, array):
    result = []
    for line in array:
      columns     = line.split()
      last_column = len(columns) - 1
      dir_path    = columns[last_column]
      result.append(dir_path)
    return result

  def subvolume_list_filter(self,target_dir,btrfs_dir,btrfs_name, source2, array):
    array   = self.subvolume_list_extract_dirs(array)
    if btrfs_name == "<FS_TREE>":
        filter1 = source2[1:] 
    else:
        filter1 = btrfs_name + "/"
   
    length  = len(filter1)
    array2  = []

    for item in array:
        # filter for the btrfs_name prefix name
        if item.startswith(filter1):
            item2 = item[length:]
            #print(item2)
            if btrfs_name == "<FS_TREE>":
                item3 = btrfs_dir + "/" +  filter1 + item2
            else:
                item3 = btrfs_dir + item2
            #print(item3)
            #print(target_dir, item3)
            if target_dir == item3 or item3.startswith(target_dir + "/"):
                array2.append(item3)
    return array2


  def subvolume_list(self,btrfs_dir, btrfs_name, source2, target_dir):
	exit_code, array= self.subvolume_list_raw(btrfs_dir)
	if exit_code != 0:
		return []
        #print("\n".join(array))
	subvolumes = self.subvolume_list_filter(target_dir,btrfs_dir,btrfs_name,source2,array)
	return subvolumes

  def delete(self,dirname):
    args = ['btrfs','subvolume', 'delete', dirname]
    print(" ".join(args))
    if DRY_RUN == True:
        return 

    self.execute(args)
    if DEBUG_LEVEL > 0:
      print("delete finished")
    # FIXME return code?

  def findmnt(self):
    # findmnt
    # -c Canonicalize all printed paths
    # -n No Headings
    # -D Imitate the output of df
    args = ['findmnt','-c','-n','-D']
    if DEBUG_LEVEL > 0:
      print(" ".join(args))
    return self.execute(args)


  def parse_btrfs_mount(self,source):
    pos = source.find("[")
    if pos == -1:
        return [ source, ''  ]
    pos_end = source.find("]", pos)
    if pos_end == -1:
        return [ source, '' ]

    source1 = source[0:pos]
    source2 = source[pos+1:pos_end]

    return [ source1, source2 ]


  def filter_findmnt_target(self,lines):
    result = []

    for line in lines:
      columns     = line.split()
      last_column = len(columns) - 1
      source      = columns[0]          
      target      = columns[last_column] 

      # source can only be device path starting with a '/', everthing else is shm, tmpfs, etc.
      if not source.startswith("/"):
          continue
      source1,source2      = self.parse_btrfs_mount(source)
      result.append([source1,source2,target])

    return result

  # In the end this method wants to match the closed "mountpoint" coming from a bottom up to the tree
  # So if the pathname is longer than any target mount points, we remove components of the dirname, to find
  # a final "exact" match. This means we have then a (partial) match of the dirname path, which goes to the
  # level where the mountpoint is

  # Test case 1: dirname is shorter  --> match root '/'
  # Test case 2: dirname is longer --> match mount point which matches first when coming from bottom (longest path) 
  # so there is someimes an exact match, somethings not

  def match_exact(self,name,lines):
    i = 0
    for line in lines:
        source1,source2,target = line
        #print("  "+target)
        if target == name:
            #print("  FOUND: "+target)
            return i
        i=i+1
    return -1

  def match_dirname(self,dirname,lines):

    components = dirname.split('/')
    length     = len(components)

    for i in reversed(range (0,length)):

        if    i == 0: name = "/"
        else:         name = "/".join(components[0:i+1])

        #print(name)
        pos = self.match_exact(name,lines)
        #print(pos)
        if pos > -1:
            #print(name)
            #source1, source2, target = lines[pos]
            #result = [ source1, source2, target, dirname]
            result = lines[pos]
            break

    # There has to be always a match, otherwise this dirname was no absolute path

    return result

  def find_longest_entry(self,source1,filtered_lines):
    result = ""
    for line in filtered_lines:
        _source1,_source2,_target = line
        if _source1 == source1 and _source2 == '':
            return _target
    return ""

  def find_match(self,dirname):
    exit_code, lines = self.findmnt()
    #print("\n".join(lines))
    if not exit_code == 0:
      return []
    filtered_lines  = self.filter_findmnt_target(lines)
    #print(filtered_lines)

    result                  = self.match_dirname(dirname,filtered_lines)
    source1,source2,target  = result
    # If there is bind mount to the directory, there is an entry, with a longer target
    prefix = self.find_longest_entry(source1, filtered_lines)
    return [ source1, source2, prefix + target, prefix + dirname ]

  def rm_recursive(self,dirname):
    args = [ 'rm', '-rf', dirname]
    print(" ".join(args))
    if DRY_RUN == True:
     return 

    proc = subprocess.Popen(args,stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    for line in proc.stdout:
      print(line.strip())
    exit_code = proc.wait()
  def find_program(self,name):
    path_array = os.environ['PATH'].split(os.pathsep)
    for path in path_array:
        filepath = os.path.join(path,name) 
        if os.path.isfile(filepath):
            return True
    return False
  def find_programs(self, required_programs):
    not_found_list = []
    for name in required_programs:
        found = self.find_program(name)
        if not found:
            not_found_list.append(name)
    return not_found_list

  def self_check(self):
    required_programs = [ 'rm', 'btrfs', 'findmnt' ]
    not_found_list = self.find_programs(required_programs)
    if len(not_found_list) > 0 :
        msg = "Necessary program not found in PATH:" +  ",".join(not_found_list)
        error_log(msg)
        return False
    return True

  def abspathes(self,path_list):
    abspath_list=[]
    for path in path_list:
        abspath_list.append(os.path.abspath(path))
    return abspath_list

  # Only Dirs as input (no files, no links etc.)
  def get_subvolumes(self, dirname):
    source1,source2,target,dirname = self.find_match(dirname)

    # source == '' --> no btrfs mount point --> there are no subvolumes under this
    is_btrfs_mount = (source2 != '' )
    if not is_btrfs_mount:
        return []

    #print(target)
    btrfs_dir, btrfs_name = self.find_btrfs(target)

    if btrfs_dir is None:
        return []

    if DEBUG_LEVEL > 0:
        print("btrfs_dir:  "+btrfs_dir)
        print("btrfs_name: "+btrfs_name)
        print("target:     "+target)

    subvolumes = self.subvolume_list(btrfs_dir, btrfs_name, source2, dirname)
    if DEBUG_LEVEL > 0:
      print("Subdirs")
      print("\n".join(subvolumes))

    return subvolumes

  # Only Dirs as input (no files, no links etc.)
  def process_dir(self, dirname):
    subvolumes = self.get_subvolumes(dirname)
    for subvolume in subvolumes:
      self.delete(subvolume)
    self.rm_recursive(dirname)

  def run(self,path_list):
    if not self.self_check():
        sys.exit(1)
    abspath_list = self.abspathes(path_list)

    for abspath in abspath_list:
        if os.path.isdir(abspath):
            self.process_dir(abspath)
        else:
           self.rm_recursive(abspath)


if __name__ == '__main__':
	if os.geteuid() != 0:
		exit("You need to have root privileges to run this script.\nPlease try again, this time using 'sudo'. Exiting.")
	parser = argparse.ArgumentParser("btrfs-rm")
	parser.add_argument('directories', metavar='directory', nargs='+',
                    help='directory which contains btrfs snapshots ')
	parser.add_argument('-t', '--test',  dest='dry_run', action='store_true', default=False,  help='dry-run without actually deleting stuff')
	parser.add_argument('-d', '--debug', metavar='level', dest='debug_level', type=int, default=0,  help='set debug level')
	args = parser.parse_args()
	DEBUG_LEVEL=args.debug_level
	DRY_RUN=args.dry_run
	btrfs = BTRFS()
	btrfs.run(args.directories)

